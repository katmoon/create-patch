#!/usr/bin/env bash
# Git patch creation tool
# v1.0
# (c) Copyright 2023 Adobe Commerce.

# 1. Check required system tools

_check_installed_tools() {
    local tools=("git" "awk" "grep" "head" "pwd" "cat" "dirname" "basename")
    for tool in "${tools[@]}"; do
        if ! command -v "$tool" >/dev/null 2>&1; then
            printf "ERROR: '%s' command is not found. Please install it to proceed.\n" "$tool"
            exit 1
        fi
    done
}

_check_installed_tools

# Determine bin path for system tools
git_bin=$(command -v git)
awk_bin=$(command -v awk)
grep_bin=$(command -v grep)
head_bin=$(command -v head)
pwd_bin=$(command -v pwd)
cat_bin=$(command -v cat)
dirname_bin=$(command -v dirname)
basename_bin=$(command -v basename)

base_name=$($basename_bin "$0")

# 2. Load env variables

tool_dir=$($dirname_bin "$0")
env_file_path="$tool_dir"/.env
if [[ -f "$env_file_path" ]]; then
    source "$env_file_path"
    echo "Loaded .env from $env_file_path."
else
    echo -e "$env_file_path was not found. Copy .env.example to .env and specify the path to the converter tool."
fi

# 3. Help menu

if [[ "$1" == "-?" || "$1" == "-h" || "$1" == "--help" ]]; then
    "$cat_bin" <<EOFH
Usage: sh $base_name -b <branch> [-r <release version>] [-v <version>] [-c <commit>:<commit>] [-m <mode>] [--help]
Generate a patch by collecting changes from the latest tag to HEAD (by default).
The tool should be run from the directory containing the repository.

-b <branch>             Specify the branch. Example: ABCD-1234.

-r <release version>    [Optional] Specify the release version to use for the patch file name.
                        If not specified, the tool will use the latest tag to identify the release version.

-v <patch version>      [Optional] Specify the patch version. Examples: v2, v3.
                        Version 1 is omitted from the patch name.
                        When not specified, no version suffix is added to the patch name.

-c <commit>:<commit>    [Optional] Generate a patch by using the changes between two arbitrary <commit>.
                        The patch will be generated by the "git diff" tool.
                        It will be treated the same way as the "git diff" command.
                        When specified, the -m parameter is ignored.

-m <mode>              [Optional] Specify the patch creation mode when branch is provided and -c is not used:
                        'tag' (default) - Create patch from latest tag to HEAD
                        'branch' - Create patch from first branch commit to HEAD

--help                  Show this help message.
EOFH
    exit 0
fi

# 4. Get options

branch=""
release_version=""
patch_version=""
collect_revisions_range=""
mode="${PATCH_MODE:-tag}"
while getopts b:v:r:c:m: opt; do
    case $opt in
    b)
        branch="$OPTARG"
        ;;
    r)
        release_version="$OPTARG"
        ;;
    v)
        patch_version="$OPTARG"
        ;;
    c)
        collect_revisions_range="$OPTARG"
        ;;
    m)
        mode="$OPTARG"
        ;;
    *)
        printf "ERROR: Invalid option: -%s\n" "$OPTARG" >&2
        exit 1
        ;;
    esac
done

ticket_number=$(echo "$branch" | $grep_bin -oE '^[A-Z0-9]*-[0-9]*')

# Validate mode value
if [[ "$mode" != "tag" && "$mode" != "branch" ]]; then
    printf "ERROR: Invalid mode '%s'. Mode must be either 'tag' or 'branch'.\n" "$mode" >&2
    exit 1
fi

# 5. Git preparations

# Determine if the current directory is under git control
is_under_git_control=777
"$git_bin" rev-parse -q >/dev/null 2>&1
is_under_git_control=$?
if [[ ! "$is_under_git_control" -eq 0 ]]; then
    printf "ERROR: The patch can't be created because the current directory is not a Git repository.\n"
    exit 1
fi

# Checkout branch
if [ -n "$branch" ]; then
    echo "Checking out branch '$branch'..."
    $git_bin fetch
    # Check for uncommitted changes
    if ! $git_bin diff --quiet; then
        printf "ERROR: There are uncommitted changes. Please commit or stash them before switching branches.\n"
        exit 1
    fi
    # Attempt to checkout the branch
    if ! $git_bin checkout "$branch" >/dev/null 2>&1; then
        printf "ERROR: The branch '%s' does not exist.\n" "$branch"
        exit 1
    fi
    echo "Successfully checked out branch '$branch'. Merging latest changes..."
    $git_bin merge
    echo "Branch checkout and merge completed"
fi

# Get the latest tag in the current branch
current_tag=$($git_bin describe --abbrev=0 --tags)

_set_branch_range() {
    local branch="$1"
    # Find the first commit that starts with the branch name
    first_branch_commit=$($git_bin log --format="%H" --all --grep="^$branch" | tail -n 1)
    if [ -z "$first_branch_commit" ]; then
        echo "WARNING: No commit found starting with '$branch'."
        exit 1
    fi

    # Get the commit before the first branch commit
    parent_commit=$($git_bin rev-parse "$first_branch_commit^" 2>/dev/null)
    if [ -z "$parent_commit" ]; then
        echo "WARNING: Could not find parent commit for first branch commit."
        exit 1
    fi

    collect_revisions_range="$parent_commit..HEAD"
    start_commit="$parent_commit"
}

_set_tag_range() {
    collect_revisions_range="$current_tag..HEAD"
    start_commit=$($git_bin rev-list "$current_tag" | $head_bin -n 1)
}


_check_git_revision() {
    local commit="$1"
    if ! git rev-parse --quiet --verify "$commit" >/dev/null 2>&1; then
        printf "ERROR: Invalid revision '%s'.\n" "$commit"
        exit 1
    fi
}

if [ -z "$collect_revisions_range" ]; then
    if [ "$mode" = "branch" ]; then
        _set_branch_range "$ticket_number"
    else
        _set_tag_range
    fi
else
    start_commit=$($awk_bin -F ":" '{print $1}' <<<"$collect_revisions_range")
    end_commit=$($awk_bin -F ":" '{print $2}' <<<"$collect_revisions_range")

    # Check if specified "start" and "end" commits exist
    _check_git_revision "$start_commit"

    # If "end" commit was specified (not empty), set the revisions range in the applicable format for "git diff" command
    if [ ! -z "$end_commit" ]; then
        _check_git_revision "$end_commit"
        collect_revisions_range="$start_commit..$end_commit"
    fi

fi

echo "Commits range: $collect_revisions_range"
echo "======== Commits in the patch: ========"
"$git_bin" log --oneline --format='%C(auto)%h %Cgreen%ad%Creset %s%C(auto)%d' --color --decorate --date=iso -50 "$collect_revisions_range"
echo "======== Based on: ===================="
"$git_bin" log --oneline --format='%C(auto)%h %Cgreen%ad%Creset %s%C(auto)%d' --color --decorate --date=iso -1 "$("$git_bin" rev-parse "$start_commit")"
echo "======================================="

# 6. Patch tool file name

# Handle DEBUG and CUSTOM suffixes
current_branch=$($git_bin rev-parse --abbrev-ref HEAD)
debug_suffix=$(echo "$current_branch" | $grep_bin -i 'debug')
custom_suffix=$(echo "$current_branch" | $grep_bin -i 'custom')

# Build the patch name components
patch_name="$ticket_number"

# Add DEBUG or CUSTOM suffix if present
if [ -n "$custom_suffix" ]; then
    patch_name="${patch_name}_CUSTOM"
elif [ -n "$debug_suffix" ]; then
    patch_name="${patch_name}_DEBUG"
fi

_get_release_version() {
    local commit="$1"
    local mode="$2"

    # Helper function to extract version from tag
    _extract_version() {
        local tag="$1"
        $awk_bin '{gsub("v",""); print}' <<<"$tag"
    }

    # If release version is specified, return it directly
    if [ -n "$release_version" ]; then
        echo "$release_version"
        return 0
    fi

    # Get tags from current branch and base commit
    current_tag=$($git_bin describe --abbrev=0 --tags)
    base_tag=$($git_bin describe --abbrev=0 --tags "$commit" 2>/dev/null)

    # Log missing tags
    [ -z "$current_tag" ] && echo "INFO: No tag found in current branch."
    [ -z "$base_tag" ] && echo "INFO: No tag found on base commit."

    # If both tags are empty, we can't determine version
    [ -z "$current_tag" ] && [ -z "$base_tag" ] && return 1

    # If both tags exist, they must match
    if [ -n "$current_tag" ] && [ -n "$base_tag" ] && [ "$current_tag" != "$base_tag" ]; then
        echo "ERROR: Base commit tag ($base_tag) differs from current tag ($current_tag)."
        echo "Please specify the correct release version using -r parameter. Run with --help for more information."
        exit 1
    fi

    # Use whichever tag is available
    _extract_version "${current_tag:-$base_tag}"
    return 0
}

# Add release version
release_version=$(_get_release_version "$start_commit" "$mode")
if [ $? -eq 0 ] && [ -n "$release_version" ]; then
    patch_name="${patch_name}_${release_version}"
    echo "Using release version: $release_version"
else
    echo "WARNING: Release version not specified. Please specify version using -r parameter. Run with --help for more information."
fi

# Add version suffix if provided
if [ -n "$patch_version" ]; then
    # Strip leading 'v' and only add suffix if not version 1
    version_num=$(echo "$patch_version" | sed 's/^v//')
    [ "$version_num" != "1" ] && patch_name="${patch_name}_v${version_num}"
fi

# Create final file names
patch_file_name_git="${patch_name}.git.patch"
patch_file_name_composer="${patch_name}.patch"

# 7. Create the patch file
if ! $git_bin diff -a -p --no-renames "$collect_revisions_range" >"$patch_file_name_git"; then
    echo "ERROR: Failed to create git patch file."
    exit 1
fi

# Create a composer version of the file
current_dir=$($pwd_bin)
patch_file_path_git="$current_dir/$patch_file_name_git"
patch_file_path_composer="$current_dir/$patch_file_name_composer"
if [ -n "$PATCH_CONVERTER_TOOL_BIN" ] && [ -f "$PATCH_CONVERTER_TOOL_BIN" ]; then
    $PATCH_CONVERTER_TOOL_BIN "$patch_file_path_git" >"$patch_file_path_composer" || \
        echo "WARNING: Failed to generate composer patch."
else
    echo "WARNING: Patch converter tool not found at '$PATCH_CONVERTER_TOOL_BIN'. Composer patch will not be generated."
fi

# 8. Report results
_check_patch_file() {
    local file="$1"
    local type="$2"
    if [ -f "$file" ] && [ "$(wc -c <"$file")" -gt 1 ]; then
        echo "$type patch created successfully. Location: $file"
    else
        echo "ERROR: Failed to generate $type patch."
    fi
}

_check_patch_file "$patch_file_path_git" "Git"
_check_patch_file "$patch_file_path_composer" "Composer"
exit 0
